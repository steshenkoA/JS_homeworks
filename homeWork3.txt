1.'number' + 3 + 3; відповідь: number33
/*  числові значення переходя в строку (string + number = string - неявне перетворення), тобто 3 та 3 стають string, і всі текстові значення складаються за допомогою знака + (всі операнди приводить до рядків і потім їх конкатенує)
INP - 'number' + 3 + 3
OUT: number33
*/

2. null + 3; відповідь: 3 
/* null перетворюється на число 0, і відбувається простий розрахунок 0 + 3 = 3
INP - 'null' + 3 
OUT: 3
*/

3. 5 && "qwerty"; відповідь: qwerty
/*перше (5) та друге значення в нас є істинні ("qwerty"), то ж система повертає останнє значення
INP - 5 && "qwerty" 
OUT: qwerty
*/

4. +'40' + +'2' + "hillel"; відповідь: 42hillel
/* числові значення складаються - 40 + 2 = 42 ( знак + всі операнди приводить до рядків і потім їх конкатенує), а потім числові значення переходя в строку (string + number = string - неявне перетворення),  і всі текстові значення складаються за допомогою знака +
INP - 5 && "qwerty"  
OUT: 42hillel
*/


5. '10' - 5 === 6; відповідь: false
/* по перше просто розраховуємо: 10 - 5 = 6 (числове значення), далі прирівнює два числа (5 та 6) по типу та значенню, як висновок вони не однакові за значенням, то буде false
INP - '10' - 5 === 6 
OUT: false
*/

6. true + false; відповідь: 1
/* true / false - булеві значення, тож мають значення 1 (true) /0 (false), сума 1 + 0 = 1
INP - true + false 
OUT: 1
*/

7.'4px' - 3; відповідь: NaN
/*  значення мінус намагається розрахувати два значення, але в цьому випадку перше значення - текстове (і текст і число), друге - число, розрахунок між стрінг та числом виводить нан
INP - '4px' - 3
OUT: NaN
*/

8.'4' - 3; відповідь: 1
/*  значення мінус намагається прирівняти два значення, в цьому випадку перше значення - текстове (але там лише число), друге - число, тому робота буде між числом та числом, як висновок 4 - 3 = 1, бо знак - намагається привести обидва операнди до чисел і потім виконати арифметичну операцію
INP - '4' - 3 
OUT: 1
*/

9. '6' + 3 ** 0; відповідь: 61
/*  ** - зведення в якусь ступінь, перше виконується зведення в ступінь: 3 в ступені 0 = 1, перше значення (там лише число) - 6, друге - число 1, простий розрахунок 6 + 1 (string + number = string - неявне перетворення) будет 61 ( знак + всі операнди приводить до рядків і потім їх конкатенує) 
INP - '6' + 3 ** 0 
OUT: 61
*/

10. 12 / '6'; відповідь: 2
/*  значення ділення намагається прирівняти два значення, в цьому випадку перше значення (там лише число) - число, друге - число, тому робота між числом та числом, бо знак / намагається привести обидва операнди до чисел і потім виконати арифметичну операцію: 12 / 6 = 2
INP - '4' - 3 
INP - 12 / '6'
OUT: 2
*/

11. '10' + (5 === 6); відповідь: 10false
/* порядок виконання дій: 1. розрахунки в скобках, 2. за скобками, перше що виконується це порівняння по типу та значенню 5 та 6, тож значення виходить false, перше значення це текстове, а друге - булеве значення, друге значення прирівнюється до текстового (string + boolean = string - неявне перетворення), тож виходить що '10' + 'false' =  '10false'
INP - '10' + (5 === 6)
OUT:10false
*/

12. null == ''; відповідь:  false
/* null - відсутність будь якого значення, '' - тип значення текстове (пусте значення), тож null не дорівнює пустому текстовому полю, тож виводиться false
INP - null == ''
OUT: false
*/

13. 3 ** (9 / 3); відповідь: 27
/* порядок виконання дій: 1. розрахунки в скобках, 2. за скобками
перше значення розраховується в скобках - 9 / 3 = 3, ** - зведення в якусь ступінь: 3 в ступені 3 буде 27
INP - 3 ** (9 / 3)
OUT: 27
*/

14. !!'false' == !!'true'; відповідь: true
/* !! призводить до його булевого еквівалента, !!'false' буде / true !!true буде = true, !!'false' =!!true буде true, тож порівнюємо і виходить true
INP - !!'false' == !!'true'
OUT: true
*/

15. 0 || '0' && 1; відповідь: 1
/* порядок виконання дій: 1.логічне і, 2. логічне чи, 3.бінарне віднімання
тож перше значення '0' && 1 (система повертає останнє - 1, бо два оператора істинні), далі розраховуємо 0 || 1 ( система повертає останнє - 1, бо 0 від'ємне значення, система повертає значення істинне), а остання дія 1 - 0 = 1
INP - 0 || '0' && 0 
OUT: 1
*/

16. (+null == false) < 1; відповідь: false
/* null це примітивний тип (тобто нічого), а +null буде 0, false - булеве число (буде 0), порівнюємо 0 та 0 буде true, true - булеве число (буде 1), 1 НЕ більше одного, тож буде false
INP - (+null == false) < 1
OUT: false
*/

17. false && true || true; відповідь: true
/* порядок виконання дій: 1.логічне і, 2. логічне чи, тож false (значення від'ємне) && true (значення істинне) 
тож система виведе від'ємне (бо не всі оператори істинні) - false, друга дія - false (значення від'ємне) || true (значення істинне) ,тож система виведе від'ємне (бо хоча б один оператор істинний) - true
INP - false && true || true
OUT: true
*/

18. false && (false || true); відповідь: false
/* порядок виконання дій: 1.логічне чи, 2. логічне і, тож false (значення від'ємне) || true (значення істинне)
тож система виведе від'ємне (бо хоча б один оператор істинний) - true, друга дія - false (значення від'ємне) && true (значення істинне),тож система виведе від'ємне (бо не всі оператори істинні) - false
INP - false && (false || true) < 1
OUT: false
*/

19. (+null == false) < 1 ** 5; відповідь: false
/* null це примітивний тип (тобто нічого), а +null буде 0, false - булеве число (буде 0), порівнюємо 0 та 0 буде true, true - булеве число (буде 1), ** - зведення в якусь ступінь, 1 в ступені 5 буде 1, 1 не більше 1, тож буде false
INP - (+null == false) < 1 ** 5
OUT: false
*/